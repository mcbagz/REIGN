# CodeBase for REIGN

This document provides an overview of the codebase for the game REIGN, covering both the frontend and backend components. Each file is summarized with its key aspects and its relationship with other parts of the codebase.

## Frontend

The frontend is responsible for rendering the game, handling user input, and communicating with the backend via WebSockets.

### Root

-   **`index.html`**: This is the foundational HTML document for the application. Its key role is to define the structure of the web page, including the containers for the loading screen, main menu, and the primary game screen. It links to the project's stylesheets (`styles.css`, `game.css`, `ui.css`) for visual presentation and includes all the necessary JavaScript files in a specific order to ensure that dependencies are loaded correctly before they are used. For example, `config.js` and `utils.js` are loaded first as they are widely used, and `main.js` is loaded last to start the application.

### CSS (`frontend/src/css/`)

-   **`game.css`**: This stylesheet is dedicated to styling the elements that appear exclusively during active gameplay. It defines the appearance of the game board, individual tiles, units, and UI components like the tile bank and worker panel. It works in conjunction with `styles.css` and `ui.css` to create a cohesive visual experience.
-   **`styles.css`**: This file contains the global styles for the application. It handles the layout of the main screens (loading, menu), the appearance of modal dialogs, and default styles for buttons and other common elements. It provides the foundational look and feel upon which other, more specific stylesheets build.
-   **`ui.css`**: This stylesheet focuses on the main game UI, such as the resource bar at the top of the screen, the player information panel, and game control buttons. It also styles the pop-up notifications (toasts) that provide feedback to the user.

### JavaScript (`frontend/src/js/`)

-   **`config.js`**: This file centralizes all static game configuration into a single `GameConfig` object. This includes fundamental values like tile sizes, unit stats, resource caps, and color palettes. By externalizing these values, it allows for easier game balancing and maintenance. It has no dependencies but is a crucial dependency for almost every other game logic file, such as `game.js`, `renderer.js`, and `unit-system.js`, which rely on it for consistent and configurable parameters.
-   **`cycle-timer.js`**: This file implements the `CycleTimer` class, a UI component responsible for the 15-second tile selection countdown. Its key feature is its ability to adapt the timer's duration based on the number of players still active in the game. It is instantiated and managed by the main `game.js` file.
-   **`debug-overlay.js`**: This file provides a `DebugOverlay` class that renders a real-time debugging panel over the game canvas using PixiJS. It displays critical metrics like network latency, frames per second (FPS), and connection status. It depends on the `latency-monitor.js` to get network data and is used by `game.js` to aid in development and performance tuning.
-   **`game-state.js`**: The `GameState` class acts as the client-side source of truth for all game-related data, such as the position of tiles, units, and player resource counts. It includes methods for initializing the game map and validating game actions like tile placement. It depends on `config.js` for initial values and `utils.js` for helper functions. It is a core dependency for `game.js`, which manages it, and `renderer.js`, which reads from it to draw the game world.
-   **`game.js`**: The `Game` class is the central orchestrator of the frontend application. It initializes and manages all major components, including the `GameState`, `GameRenderer`, `WebSocketClient`, and all game systems (e.g., `TileSystem`, `UnitSystem`). It contains the main game loop, handles user input events by delegating them to the appropriate systems, and manages the overall flow of the game. It is the most interconnected file, depending on nearly every other module to function.
-   **`latency-monitor.js`**: This utility class, `LatencyMonitor`, is responsible for measuring the connection quality to the server. It periodically sends ping messages and measures the response time. It is a dependency for the `debug-overlay.js`, which visualizes the data it collects, and is managed by the `game.js` class.
-   **`main.js`**: This is the main entry point for the JavaScript application. It initializes the `GameApp` class, which controls the high-level screen flow (from loading screen to main menu to the game itself). It sets up the initial event listeners for the main menu buttons, which in turn trigger the creation of the `Game` object.
-   **`offline-banner.js`**: This file defines the `OfflineBanner` class, a simple UI component that appears at the top of the screen to inform the user when the WebSocket connection to the server has been lost. It is managed by `game.js` and listens to events from the `websocket-client.js`.
-   **`renderer.js`**: The `GameRenderer` class handles all rendering using the PixiJS library. Its responsibilities include setting up the PixiJS application, managing the viewport for panning and zooming, and drawing the grid, tiles, and units. It depends heavily on `game-state.js` to get the data it needs to render the current state of the game and on `config.js` for dimensions and sizes.
-   **`resource-manager.js`**: This class, `ResourceManager`, is responsible for all client-side logic related to player resources (gold, food, faith). It depends on `game-state.js` to access player data and is used by `game.js` to manage the resource-related aspects of the game.
-   **`tile-system.js`**: The `TileSystem` class manages the logic for tile placement. This includes the 15-second tile offer cycle, the modal window for choosing tiles, and the player's personal tile bank. It depends on `game-state.js` to validate and update the board state and is controlled by the main `game.js` class.
-   **`toast-manager.js`**: This file implements a `ToastManager` class that creates and manages on-screen notifications (toasts). These toasts provide brief, non-intrusive feedback to the user for actions like successful placements or errors. It is used by `ui-manager.js` and the main `game.js` to communicate information to the player.
-   **`tween-system.js`**: This file provides a wrapper around the GSAP (GreenSock Animation Platform) library to simplify the creation of smooth animations. It is used by other systems, particularly `unit-system.js` and `renderer.js`, to animate unit movements and UI transitions, making the game feel more dynamic and polished.
-   **`ui-manager.js`**: The `UIManager` class is a centralized module for managing various user interface components. It handles the display and interaction logic for modals, tooltips, and the main resource bar. It depends on `game-state.js` to display up-to-date information and is managed by the `game.js` class.
-   **`unit-commands.js`**: This `UnitCommands` class is responsible for interpreting player input related to military units. It handles unit selection (single-click) and issuing commands like movement or attack (right-click). It depends on `game-state.js` to identify units at a given position and `unit-system.js` to execute the corresponding actions.
-   **`unit-system.js`**: The `UnitSystem` class manages all aspects of units within the game. This includes creating and rendering unit sprites, handling movement logic, and updating their visual state. It depends on `game-state.js` for unit data, `renderer.js` to draw the units on the canvas, and `tween-system.js` to animate their movements smoothly.
-   **`unit-training-ui.js`**: This file defines the `UnitTrainingUI` class, which presents the player with a context menu for training new units when they double-click on a compatible building (like a Barracks or City). It depends on `game-state.js` to check player resources and `unit-system.js` to initiate the training process.
-   **`utils.js`**: This is a utility file containing a collection of miscellaneous helper functions that are used throughout the project. These include mathematical clamps, grid-to-pixel conversions, and resource calculations. It has no dependencies and is imported by many other files that require its reusable logic.
-   **`websocket-client.js`**: The `WebSocketClient` class establishes and manages the WebSocket connection with the backend server. It handles sending commands, receiving state updates, and automatic reconnection attempts. It is a critical dependency for `game.js`, which uses it as the primary means of network communication.

### TypeScript (`frontend/src/`)

-   **`debug/latencyMonitor.ts`**: This is a TypeScript version of the latency monitor. It provides real-time ping measurements and connection quality metrics by interacting with the WebSocket client. It is a dependency for `debug/overlay.ts`, which visualizes its data.
-   **`debug/overlay.ts`**: A TypeScript implementation of the debug overlay. It uses PixiJS to render a panel with performance information like FPS and network latency. It depends on `debug/latencyMonitor.ts` to source its network data.
-   **`net/messageTypes.ts`**: This file defines the TypeScript interfaces and enums for all WebSocket messages exchanged between the client and server. It ensures type safety in network communication and is a dependency for `net/wsClient.ts`.
-   **`net/wsClient.ts`**: A more robust, TypeScript-based WebSocket client. It manages the connection lifecycle, automatic reconnection, and message routing based on type. It depends on `net/messageTypes.ts` to provide strong typing for all incoming and outgoing messages.
-   **`render/tweenSystem.ts`**: A TypeScript implementation of the GSAP animation wrapper. It provides a type-safe interface for creating smooth animations for game objects and UI elements, helping to interpolate visual states between server updates.
-   **`state/diffPatch.ts`**: This utility file provides functions for generating and applying JSON Patches (RFC 6902). Its purpose is to calculate the difference between two game states. It is a key dependency for `state/prediction.ts`, which uses it to reconcile client and server states.
-   **`state/prediction.ts`**: This file implements a sophisticated system for client-side prediction and server reconciliation. It allows the client to predict the outcome of user actions immediately, providing a responsive experience, and then later reconciles its predicted state with the authoritative state from the server. It depends on `state/diffPatch.ts` to identify and handle discrepancies.
-   **`types/*.ts`**: This directory contains TypeScript definition files generated from JSON schemas. `game-state.ts`, `tile.ts`, `unit.ts`, and `websocket-message.ts` define the strict data structures for all major game entities and communication protocols. They are dependencies for any part of the TypeScript codebase that needs to interact with these objects, ensuring type safety and preventing common data-related bugs. `index.ts` serves as a barrel file, re-exporting all types for convenient importing.
-   **`ui/toastManager.ts`**: A TypeScript version of the `ToastManager`. It handles the display of on-screen notifications in a type-safe manner, managing a queue of messages and their presentation to the user.

## Backend

The backend is a Python FastAPI application that manages the authoritative game state, handles game logic, and communicates with clients via WebSockets.

### Root

-   **`requirements.txt`**: This file lists all the Python packages required for the backend to run, such as `fastapi`, `uvicorn`, and `websockets`. It is used by `pip` to install the necessary dependencies.

### Source (`backend/src/`)

-   **`main.py`**: This is the main entry point for the FastAPI server. It defines the HTTP endpoints for matchmaking (`/match`) and the primary WebSocket endpoint (`/ws/{room_id}/{player_id}`) for real-time game communication. It depends on `game_room.py` to get or create `Room` instances for players and uses the Pydantic models from the `models` directory to structure and validate API data.
-   **`game_room.py`**: This is the heart of the backend. It defines the `Room` class, which encapsulates the entire state and logic for a single game instance, including the list of players, the game state, and the main game loop. The `RoomManager` class is responsible for creating, tracking, and cleaning up these rooms. This file depends on all the Pydantic models in `models/` to define its structure and on `combat_system.py` and `pathfinding.py` to handle complex game logic.
-   **`combat_system.py`**: This module contains the logic for handling combat between units. A key feature is its use of a `SpatialHash`, a data structure that provides highly efficient lookups of units in a given area. This is critical for performance, as it avoids having to check every unit on the map when determining targets. It is used by the `UnitSystem` (defined in `models/unit.py`) to process attacks during the game loop.
-   **`pathfinding.py`**: This file provides a `Pathfinder` class that implements the A* search algorithm, a common and efficient method for finding the shortest path between two points on a grid. It is used by the `UnitSystem` to calculate the route a unit will take when a move command is issued, taking into account obstacles like other units or difficult terrain.

### Models (`backend/src/models/`)

-   **`game_state.py`**: Defines the Pydantic model for the `GameState`, which is the authoritative representation of a single game. It includes all information, such as the list of players, the board state (tiles and units), the current turn, and game settings. It is the central data structure used by `game_room.py`.
-   **`tile.py`**: Defines the Pydantic model for a `Tile`, including its type, position, owner, and any workers placed on it. This model is used within the `GameState` to represent the game board.
-   **`unit.py`**: Defines the Pydantic model for a `Unit`, detailing its stats (HP, attack, etc.), owner, position, and current status. It also contains the `UnitSystem` class, which centralizes logic for managing all units, such as processing combat and movement. It depends on `pathfinding.py` and `combat_system.py` to execute these complex actions.
-   **`websocket_message.py`**: This file defines the Pydantic model for the WebSocket message protocol, ensuring that all communication between the client and server is well-structured and validated. It is used by `main.py` and `game_room.py` whenever messages are sent or received.