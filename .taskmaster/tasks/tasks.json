{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Repository & Project Infrastructure",
        "description": "Create monorepo with PixiJS front-end and FastAPI back-end, configure build, linting, CI, and hosting scaffolding.",
        "details": "• GitHub repo → main branch protected, develop branch for daily work.\n• Monorepo layout:\n  /frontend (Vite + PixiJS v7, TS, ESLint, Prettier)\n  /backend (Python 3.12, FastAPI, uvicorn, poetry)\n  /shared (JSON schemas for tiles/units)\n• Add GitHub Actions:\n  ‑ Frontend: npm ci → npm run build → upload artifact\n  ‑ Backend: poetry install → pytest → uvicorn dry-run\n• Netlify & Render free tiers for preview deploys.\n• .env.sample with WS_URL, API_URL.\n",
        "testStrategy": "Run CI pipeline on PR creation; verify successful build & test stages. Open preview URLs, confirm 200 OK for index.html and /docs (FastAPI swagger).",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Define Core Data Schemas & API Contracts",
        "description": "All core data contracts are now formalized and validated. JSON Schemas, mirrored Pydantic models, and auto-generated TypeScript types provide a single-source-of-truth for tiles, units, full game state, and WebSocket messaging envelopes.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "✅ JSON Schemas (shared/schemas)\n  • tile.schema.json – tile structure with worker slot, resource bundle, owner, HP, edge meta, etc.\n  • unit.schema.json – full combat stats, targeting, type effectiveness, status flags\n  • game-state.schema.json – authoritative game snapshot: players, tiles, units, settings, metadata\n  • websocket-message.schema.json – {type:\"cmd|state|error\", version, ts, payload, ack?, retry?}\n\n✅ Python Pydantic Models (backend/src/models)\n  • Auto-generated from the above schemas and hand-tweaked for enum/type safety\n  • Round-trip serialization using orjson\n\n✅ TypeScript Types (frontend/src/types)\n  • Generated via quicktype in build script `npm run build:types`\n  • Re-exported barrel file `index.ts` for easy imports\n\n✅ Contract Features\n  • Command, state, and error payload patterns with priority, ack, retry, and versioning support\n  • Strict validation across the stack; sample data fixtures included for integration tests\n",
        "testStrategy": "Python: 12 pytest cases validate model construction, validation errors, and round-trip serialization.\nTypeScript: 4 jest tests confirm schema <-> type coherence and client serialization.\nCI step runs `jsonschema-cli validate` on sample payloads and `npm run build:types` to catch drift.\nSwagger/OpenAPI docs auto-generated from pydantic models for backend reference.",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Tile Grid & Placement UI (Single-Player)",
        "description": "Render 40×40 grid, 15-second tile offer cycle, placement rules, banking queue and starter setup.",
        "details": "Frontend/TypeScript:\n• const grid = new Map<string, Tile>(); // key = `${x},${y}`\n• PixiJS container per tile; use viewport plugin for pan/zoom.\n• setInterval(15_000, () => showTileOptions());\n• showTileOptions(): draws modal with 3 random tiles, onClick => placeTile(x,y, tile).\n• placeTile validates adjacency (touches ≥1 tile), updates grid and UI.\n• Maintain `bank:Array<Tile>` size ≤3; user can drag queued tiles.\n• Init function seeds quadrants with capital cities, scatters resources/marshes.\n• Persist state in localStorage for reload resilience.\n",
        "testStrategy": "Cypress e2e:\n1. Load page ⇒ expect 4 capitals placed.\n2. Wait 15s ⇒ modal appears with 3 tiles.\n3. Click tile, hover valid square ⇒ highlight, click ⇒ tile placed.\n4. Try illegal placement ⇒ placement rejected.\n5. Queue >3 tiles ⇒ oldest discarded.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement 40x40 Grid Rendering & Viewport",
            "description": "Set up the visual 40x40 tile grid using PixiJS, ensuring each tile has its own container. Integrate the viewport plugin for pan and zoom functionality, allowing users to navigate the large grid.",
            "dependencies": [],
            "details": "Render 40×40 grid. PixiJS container per tile; use viewport plugin for pan/zoom.\n<info added on 2025-07-15T17:22:00.984Z>\nCompleted implementation of Subtask 3.1:\n\n• Integrated pixi-viewport (drag, pinch, wheel, clamp; zoom 0.5×–3×).  \n• Refactored GameRenderer to create a Viewport and populate 40 × 40 tile containers at correct world coordinates.  \n• Added subtle gridline background and per-tile rendering with colour/symbol by type.  \n• Enabled interactivity: hover highlights, click dispatches custom `tile:select` events.  \n• Implemented tile-highlight utility for valid placement previews.  \n• Viewport script embedded in index.html and verified on desktop/mobile.\n\nGrid is now fully navigable and responsive; marking Subtask 3.1 as complete and ready to begin Subtask 3.2 (Initial Map Setup & Local Storage).\n</info added on 2025-07-15T17:22:00.984Z>",
            "status": "done",
            "testStrategy": "Visually verify grid renders correctly and pan/zoom works smoothly."
          },
          {
            "id": 2,
            "title": "Implement Initial Map Setup & Local Storage",
            "description": "Develop the initialization function responsible for seeding the game map with starting elements, specifically placing capital cities in quadrants and scattering resources/marshes. Also, implement state persistence using localStorage to ensure game state can be reloaded.",
            "dependencies": [
              1
            ],
            "details": "Init function seeds quadrants with capital cities, scatters resources/marshes. Persist state in localStorage for reload resilience.\n<info added on 2025-07-15T17:26:35.603Z>\nCompleted implementation:\n\n• initializeMap(): wipes grid, instantiates 40×40 Tile objects, and calls placeCapitalCities(), scatterResourceTiles()  \n• placeCapitalCities(): drops 4 capitals at (10,10), (30,10), (10,30), (30,30) and assigns owners  \n• scatterResourceTiles(): randomly selects 3 legal coordinates per resource type (mine, orchard, monastery, marsh) while enforcing ≥3-tile Manhattan distance from any capital  \n• Tile model expanded to include {type, resources, hp, edges, ownerId} and adjacency helpers  \n\nPersistence layer:  \n• saveToLocalStorage(), loadFromLocalStorage(), clearLocalStorage() with versioning key \"civ-game-v1\"  \n• enableAutoSave(intervalMs = 10_000) / disableAutoSave() integrated into Game lifecycle (init, beforeunload)  \n\nUI hooks:  \n• setupInitialState() now attempts load → fallback initializeMap() → immediate render  \n• tileRenderer draws all seeded tiles on first frame  \n\nOutcome: initial board renders deterministically, resource yields are correct, and full game state survives page refreshes. Subtask 3.2 is now functionally complete.\n</info added on 2025-07-15T17:26:35.603Z>",
            "status": "done",
            "testStrategy": "Load page ⇒ expect 4 capitals placed."
          },
          {
            "id": 3,
            "title": "Implement 15-Second Tile Offer Cycle & Modal",
            "description": "Create a mechanism to periodically offer new tiles to the player every 15 seconds. This involves a modal UI that displays 3 random tile options, allowing the user to select one for placement.",
            "dependencies": [
              1
            ],
            "details": "setInterval(15_000, () => showTileOptions()); showTileOptions(): draws modal with 3 random tiles, onClick => placeTile(x,y, tile).\n<info added on 2025-07-15T17:29:39.054Z>\nImplemented full production-ready tile offer system:\n\n• Game lifecycle hooks: startPlacementCycle() begins 15-sec setInterval after game start; stopPlacementCycle() clears timer on game end or modal close to prevent leaks.  \n• Modal pipeline: initializeModal() sets DOM refs/listeners; showTileOptions() populates and opens modal every 15 s; closeModal() handles teardown.  \n• Tile generation: generateTileOptions() pulls three random Tile prototypes, enriching them via getTileResources(), generateTileEdges(), getTileHP(); resource mapping added (mines=25 g, orchards=25 f, monasteries=25 f, cities=15 g+15 f).  \n• Selection timer: 15-s countdown shown in modal, pulses during final 5 s, auto-selects first tile on expiry.  \n• Tile bank: addToTileBank() maintains a FIFO queue capped at 3 entries for later placement.  \n• UI/UX polish: responsive preview cards (120 px), color-coded resource badges, hover/scale animations, countdown pulse.  \n• All timers, listeners, and DOM nodes are cleaned up on modal close or game end.  \n\nSubtask 3.3 is now feature-complete and ready for hand-off to Subtask 3.4 (Tile Placement Rules & Grid Update).\n</info added on 2025-07-15T17:29:39.054Z>",
            "status": "done",
            "testStrategy": "Wait 15s ⇒ modal appears with 3 tiles."
          },
          {
            "id": 4,
            "title": "Implement Tile Placement Rules & Grid Update",
            "description": "Develop the core `placeTile` function responsible for validating tile placement based on adjacency rules (must touch at least one existing tile). Upon valid placement, update the internal `grid` data structure and reflect the change in the UI.",
            "dependencies": [
              1
            ],
            "details": "placeTile validates adjacency (touches ≥1 tile), updates grid and UI. const grid = new Map<string, Tile>(); // key = `${x},${y}`\n<info added on 2025-07-15T17:33:54.288Z>\nImplementation completed and validated:\n\n• Added comprehensive placeTile() pipeline (isValidCoordinate, hasAdjacentTile, isEdgeCompatible, edgesMatch) enforcing full adjacency and edge-matching rules.  \n• Edge compatibility matrix: field↔any, city↔city/field, marsh↔marsh/field; rejects all other combinations.  \n• Grid mutation: tiles stored in Map<\"x,y\",Tile>, owner/workers/timestamp auto-assigned, ‘tilePlaced’ event dispatched and state persisted to localStorage.  \n• getValidPlacementPositions() scans entire 40×40 grid, returns highlight list for UI; scales efficiently with grid size.  \n• Placement-mode UI: enter/exit flows, green highlight for valid cells, red flash + toast on invalid attempt, cancel button & Esc support.  \n• Interactive grid hooks: unified tileClick dispatcher, showPlacementError(), placement instruction overlay.  \n• Resource manager integration: automatic resource grant on successful placement.  \n• All flows tested: adjacency, edge rules, UI feedback, persistence across refresh. Subtask functionality considered complete; ready to advance to Tile Banking Queue implementation.\n</info added on 2025-07-15T17:33:54.288Z>",
            "status": "done",
            "testStrategy": "Click tile, hover valid square ⇒ highlight, click ⇒ tile placed. Try illegal placement ⇒ placement rejected."
          },
          {
            "id": 5,
            "title": "Implement Tile Banking Queue & User Interaction",
            "description": "Create and manage a tile banking queue (`bank:Array<Tile>`) that holds up to 3 tiles. Implement functionality for users to drag tiles from this queue onto the grid for placement. Ensure the queue size is maintained, discarding the oldest tile if a new one is added when the bank is full.",
            "dependencies": [
              1,
              4
            ],
            "details": "Maintain bank:Array<Tile> size ≤3; user can drag queued tiles.\n<info added on 2025-07-15T17:39:03.928Z>\nImplemented full tile banking system and user interaction layer:\n\n• FIFO queue (`bank:Array<Tile>`) capped at 3; `addToTileBank()` auto-drops oldest entry when full, `removeTileFromBank()` cleans up UI/state.  \n• Bottom-right Tile Bank UI with header count (e.g., “2/3”), empty-state message, and rich preview cards showing type, resources, HP.  \n• Click-to-place flow: `selectTileFromBank()` enters placement mode, `clearBankSelection()` resets on success/failure.  \n• Drag-and-drop flow: HTML5 drag attributes on cards, drag overlay with opacity/rotation; canvas `dragover`/`drop` events call `handleCanvasDrop()`—converts viewport→world→grid and invokes existing placement validation.  \n• Events: `tileSelectedFromBank`, `tileDragStart`, `tileDragEnd`; maintains `draggedTile` & `draggedTileIndex`, resets cleanly after placement.  \n• CSS: ~150 lines for responsive layout, hover/drag animations, z-index layering.  \n• Automated UI refresh on every add/remove; visual feedback for valid/invalid targets; queue behavior verified via manual and automated tests.\n</info added on 2025-07-15T17:39:03.928Z>",
            "status": "done",
            "testStrategy": "Queue >3 tiles ⇒ oldest discarded. Verify drag-and-drop functionality for placing tiles from the bank."
          }
        ]
      },
      {
        "id": 4,
        "title": "Resource Generation & Worker Management",
        "description": "Add real-time resource tick, 5 workers per player with placement/recall and additive production logic.",
        "details": "• resources = {gold:0, food:0, faith:0, cap:500};\n• requestAnimationFrame loop accumulates deltaTime; every 1000 ms call tickResources().\n• tickResources(): iterate grid, sum yields per connected component using flood-fill keyed by owner & tileType.\n• Worker UI: sidebar list with drag-and-drop onto eligible tiles; recall sets `worker=null` then `setTimeout(10_000,… )` before reuse.\n• Update resource bar sprites (Pixi bitmap text) in real time.\n• Prevent overflow >cap.\n",
        "testStrategy": "Jest unit tests for tickResources() on mocked grids.\nManual QA: place 3 connected cities + 1 magistrate ⇒ resource/sec equals 3. Recall worker ⇒ production drops after 0 s; worker re-available after 10 s.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement real-time resource tick scheduler",
            "description": "Create the frame loop that accumulates deltaTime and invokes tickResources() every 1000 ms, guaranteeing consistent behaviour even when the tab is hidden.",
            "dependencies": [],
            "details": "• Add `let delta = 0; let last = performance.now();`\n• In the global `requestAnimationFrame` handler, compute `const now = performance.now(); delta += now - last; last = now;`\n• While `delta >= 1000` call `tickResources()` then `delta -= 1000`.\n• Use `document.visibilitychange` to switch to `setInterval(1000)` when the page is not visible; switch back on focus.\n• Expose `startResourceLoop()` and `stopResourceLoop()` helpers for later tests.\n• Ensure the loop is started from the game bootstrap logic.\n<info added on 2025-07-15T21:40:05.053Z>\n• Implemented deltaTime accumulator that invokes tickResources() exactly once per 1000 ms, independent of frame rate  \n• Added visibilitychange handler that swaps the RAF-driven loop for a setInterval(1000) fallback when the page is hidden, then restores RAF on focus  \n• Exposed ResourceManager.start(), stop(), and destroy() methods for bootstrap, testing, and cleanup scenarios  \n• Hooked ResourceManager.update(delta) into the central Game.update() to reuse the existing RAF and prevent duplicate loops  \n• Guaranteed full teardown by clearing timers and removing event listeners on destroy(), eliminating potential memory leaks  \n• Manual smoke tests verify stable 60 fps with precise 1 s ticks and uninterrupted resource generation through repeated tab hide/show cycles\n</info added on 2025-07-15T21:40:05.053Z>",
            "status": "done",
            "testStrategy": "Jest: mock `performance.now()` and `requestAnimationFrame` to fast-forward 5 s; assert that tickResources was called exactly 5 times."
          },
          {
            "id": 2,
            "title": "Build connected-tile additive yield calculation",
            "description": "Implement tickResources() so it walks the grid, groups connected tiles by owner & tileType, and sums their yields additively before updating player resource pools.",
            "dependencies": [
              1
            ],
            "details": "• Accept the immutable `grid: Map<string, Tile>`.\n• For each unvisited tile with an owner, perform BFS flood-fill across orthogonally adjacent tiles with same owner & tileType.\n• Accumulate yields: `componentYield += tile.baseYield + (tile.worker ? tile.worker.bonus : 0)`.\n• After finishing a component, add its yield to `playerResources[owner][resourceType]`.\n• Call `applyCap(playerResources, cap)` to clamp totals.\n• Return a diff object `{gold:+x, food:+y, faith:+z}` for UI update consumption.\n<info added on 2025-07-15T21:44:12.643Z>\ntickResources() completed with BFS-based component detection, additive yield aggregation, worker validation, and 500-point cap enforcement. Returns per-player delta object for UI binding. Overflow is logged for analytics. Grid traversal uses a Set-based visited cache to prevent double counting. Ready for integration tests and hand-off to worker placement logic in subtask 4.3.\n</info added on 2025-07-15T21:44:12.643Z>",
            "status": "done",
            "testStrategy": "Jest: feed mocked 6×6 grids, expect correct totals for various connected shapes; verify cap truncation when totals exceed 500."
          },
          {
            "id": 3,
            "title": "Implement worker data model and placement/recall logic",
            "description": "Create the Worker class, enforce 5-per-player limit, handle drag placement onto eligible tiles, and implement 10-second cooldown on recall.",
            "dependencies": [
              2
            ],
            "details": "• Define `interface Worker { id:number; owner:string; status:'idle'|'deployed'|'cooldown'; tileKey?:string; }`.\n• Attach `playerWorkers: Record<string, Worker[]>` to game state; pre-populate 5 idle workers per player.\n• `placeWorker(workerId, tileKey)`: validate worker idle, tile is owned by player, slot empty ⇒ set status='deployed', tile.worker reference.\n• `recallWorker(workerId)`: remove reference from tile, set status='cooldown', clear tileKey, start `setTimeout(10000, () => worker.status='idle')`.\n• Emit custom events `workerPlaced` and `workerRecalled` for UI & analytics.\n<info added on 2025-07-15T22:13:31.309Z>\n• Updated GameConfig constants: STARTING_WORKERS = 5 and WORKER_RECALL_TIME = 10_000 ms.  \n• Extended Worker interface to include `cooldownTimer?: ReturnType<typeof setTimeout>` for managing recall delay.  \n• Added `workersById: Map<number, Worker>` to game state for constant-time lookup in addition to per-player arrays.  \n• Completed WorkerManager methods:  \n  – `placeWorker` fully validates idle status, tile ownership, and per-tile capacity (GameConfig.TILE_STATS) before deployment.  \n  – `recallWorker` now triggers a 10-second cooldown, stores the timer reference, and automatically flips the worker back to `idle`.  \n• New custom event `workerCooldownFinished` emitted after cooldown expires, complementing `workerPlaced` and `workerRecalled`.  \n• Implemented helper accessors (`getWorkersByPlayer`, `getAvailableWorkers`, `getDeployedWorkers`, `getWorkersOnTile`) for UI and logic layers.  \n• Integrated worker presence into ResourceManager: `tileGeneratesResources` and `calculateComponentYield` now call `getWorkersOnTile` so tiles that require workers only yield when staffed.  \n• Implementation verified with unit tests; subtask ready to move to UI integration (4.4).\n</info added on 2025-07-15T22:13:31.309Z>",
            "status": "done",
            "testStrategy": "Jest: simulate placement to a valid tile, expect status updates; recall and advance timers with fake timers, expect cooldown then idle after 10 s; ensure no more than 5 deployed at once."
          },
          {
            "id": 4,
            "title": "Create worker management UI (sidebar & on-grid interactions)",
            "description": "Build PixiJS components that display all five workers, allow drag-and-drop onto eligible tiles, visualise cooldown timers, and support click-to-recall.",
            "dependencies": [
              3
            ],
            "details": "• Sidebar: `workersContainer` vertical list; for each worker create a sprite (idle=green, deployed=blue, cooldown=gray overlay with countdown).\n• Drag: on `pointerdown` begin drag, on `pointermove` follow cursor, on `pointerup` test hit on eligible tile → call `placeWorker`.\n• Highlight eligible tiles during drag (e.g., yellow border).\n• Recall: add `pointertap` listener on a worker-occupied tile; confirm recall then call `recallWorker`.\n• Listen to `workerPlaced/workerRecalled` events to refresh sprites and tooltips.\n• Use Tween.js or gsap to animate cooldown radial fill.",
            "status": "done",
            "testStrategy": "Manual QA: drag an idle worker onto owned tile ⇒ sprite turns blue; click deployed worker ⇒ turns gray with 10-s countdown; after countdown sprite returns to green. Cypress: record pointer events and assert DOM changes."
          },
          {
            "id": 5,
            "title": "Update resource bar UI with real-time values & cap feedback",
            "description": "Render resource amounts via Pixi bitmap text, refresh them every tick, animate value changes, and visually warn when near or at cap.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "• Create `resourceBarContainer` holding bitmap texts for gold, food, faith.\n• Subscribe to the diff returned by tickResources(); on change tween the number over 0.3 s for smoothness.\n• After applying `applyCap`, if value >= 0.9*cap tint text yellow, if value == cap tint red.\n• Add subtle ‘overflow blocked’ toast when production would exceed cap.\n• Expose `updateCap(newCap)` to allow future upgrades.\n• Ensure bar updates run inside the same RAF as game loop to keep FPS persistent.\n<info added on 2025-07-15T23:25:33.738Z>\n• Added DEBUG_RESOURCE_UI flag and console.group-based tracing that logs tickResources diff, cap enforcement, tween targets, and overflow checks each frame.  \n• updateResourceBar() now forces a text refresh even when diff === 0, preventing stale or blank values during periods of zero production.  \n• initResourceBar() now verifies bitmap font availability; if missing, it automatically falls back to styled Pixi.Text to avoid hard crashes in dev builds.  \n• Unified the resourceBar refresh path so the same update function is invoked from both the RAF loop and the optional fixed-interval test loop, ensuring identical behaviour across modes.  \n• Integrated overflow-toast emitter into shared ToastManager to reuse fade-in/fade-out animations and reduce draw calls.\n</info added on 2025-07-15T23:25:33.738Z>",
            "status": "done",
            "testStrategy": "Jest: spy on Pixi text `text` setter to ensure updates on each diff; simulate resource totals reaching thresholds and assert tint values. Manual: watch numbers animate in real time without frame drops."
          }
        ]
      },
      {
        "id": 5,
        "title": "Unit Rendering, Movement & Combat",
        "description": "Create sprite-based units with stat sheet, pathing, combat radius and rock-paper-scissors multipliers.",
        "details": "• classes: Unit (id, type, hp, atk, speed, owner)\n• Pathing: simple A* on grid avoiding marsh weight=2.\n• Movement loop: deltaPos = speed * deltaTime; update sprite.x/y.\n• Combat: spatial hash per frame to detect enemies within range; apply damage/sec = atk * multiplier.\n• Training: city/barracks right-click ⇒ show menu; deduct gold/food; setTimeout( buildTime ).\n• Death: hp<=0 ⇒ fade-out animation, remove from state.\n",
        "testStrategy": "Mocha headless:\n• Spawn infantry vs archer adjacent ⇒ expect infantry hp >0, archer <0 after simulation.\nPerformance: spawn 50 units, measure FPS >55 on Chrome laptop.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "FastAPI WebSocket Server & Game State Sync",
        "description": "Create WebSocket endpoints, authoritative tick loop, and in-memory game rooms supporting 2-4 players.",
        "details": "Python 3.12 + FastAPI:\n• /ws/{room_id}/{player_id}\n• Connection handler joins `Room` dataclass: {players:set, state:GameState, tick=0}.\n• `asyncio.create_task(room_loop(room))` runs 10 fps:\n   broadcast({type:\"state\", payload=room.state})\n• Accept client cmds: {type:\"cmd\", action:\"placeTile|moveUnit|trainUnit\", data:{…}}; validate vs state; mutate.\n• Matchmaking endpoint /match ⇒ returns room_id.\n• Use `orjson` for fast serialization.\n",
        "testStrategy": "pytest + WebSocketTestSession:\n• Connect 3 clients ⇒ receive identical state hashes.\n• Send illegal tile placement ⇒ server returns error message.\nBenchmark: simulate 4 players 200 cmds/s ⇒ CPU <50 %.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Frontend Multiplayer Integration & UI Feedback",
        "description": "Wire PixiJS client to WebSocket, reconcile authoritative state, display other players’ actions and latency smoothing.",
        "details": "• ws = new WebSocket(`${WS_URL}/ws/${room}/${player}`);\n• Maintain localPrediction → on server update run diff patch; tween position to avoid snap.\n• Toast banner when server message `{type:\"action\", msg}` (e.g., \"Player2 placed a city\").\n• Adaptive tile cycle timer based on playersAlive (60s/4p, 45s/3p…).\n• Handle disconnect/reconnect: exponential back-off, state re-sync request.\n",
        "testStrategy": "Run 2 browser tabs, perform actions, observe sync within <200 ms.\nThrottle latency 200 ms via DevTools ⇒ motion remains smooth with interpolation.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Conquest & Watchtower Mechanics",
        "description": "Add capital HP, elimination flow, raiding, tile capture, and watchtower defense aura.",
        "details": "Server-side:\n• Tile model gains `capturable:bool`.\n• Damage rules: siege ×2 vs buildings.\n• On capital hp<=0 ⇒ mark player eliminated, remove from placement cycle, broadcast victory check.\n• Raiding: attacker action steals 0.1 × defender tile resources, updates both inventories.\n• Watchtower: when unit enters aura radius=2, apply defBuff=1.25 in combat calc.\nClient:\n• Capital hp bar UI, elimination banners.\n",
        "testStrategy": "Integration test: python simulate players, destroy capital ⇒ eliminated flag true, placement timer adjusts.\nUnit tests for aura function defBuff().",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Tech Tree & Progression System",
        "description": "Implement Manor→Duchy→Kingdom upgrades, tech menu, and monastery abilities with cost deductions and cooldowns.",
        "details": "• Add `player.level` enum.\n• Upgrade action validates resources, triggers 5-s progress bar; upon completion unlocks new units/tiles.\n• TechMenu React-style overlay in Pixi UI, listing Upgrade buttons with tooltip showing effects.\n• Abilities: Heal & Inspire cost faith; add cooldown Map<ability, ts>.\n• Balance constants stored in /shared/balance.ts & mirrored in Python.\n",
        "testStrategy": "Unit: attempt Duchy upgrade with insufficient resources ⇒ blocked.\nE2E: speedrun Manor→Kingdom in ~15 min, monitor resource curve matches PRD targets.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "AI Opponents, Visual/Audio Polish & Performance Optimization",
        "description": "Create heuristic-based AI, replace placeholders with final assets, add SFX/BGM, and profile render loop.",
        "details": "AI (backend):\n• Decision tree each 5 s: if resourcesTileNearby ⇒ place, else if armyWeak ⇒ train, else attack weakest rival.\n• Pathfinding shares A* util.\nVisuals:\n• Load texture atlas .json generated by Aseprite.\n• Animations: GSAP timeline for tile fade-in, unit sprite sheet walk cycles.\nAudio:\n• Howler.js for music loop + combat SFX.\nPerformance:\n• use PIXI.BaseTexture.fromBuffer batching; limit units/player 50; auto-purge textures on lost context.\n",
        "testStrategy": "Play solo vs 3 AIs: ensure they progress Manor→Kingdom and attack.\nLighthouse performance audit: 60 FPS, memory <300 MB on Chrome i3 laptop.\nAudio: mute/unmute toggles without crackle.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-15T16:18:01.677Z",
      "updated": "2025-07-15T22:36:20.439Z",
      "description": "Tasks for master context"
    }
  }
}